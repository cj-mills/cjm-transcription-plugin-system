[
  {
    "objectID": "plugin_interface.html",
    "href": "plugin_interface.html",
    "title": "Transcription Plugin Interface",
    "section": "",
    "text": "source",
    "crumbs": [
      "Transcription Plugin Interface"
    ]
  },
  {
    "objectID": "plugin_interface.html#how-it-works",
    "href": "plugin_interface.html#how-it-works",
    "title": "Transcription Plugin Interface",
    "section": "How It Works",
    "text": "How It Works\nHost Process                              Worker Process (Isolated Env)\n┌─────────────────────┐                  ┌─────────────────────────────┐\n│ audio = AudioData(  │                  │                             │\n│   samples=np.array, │                  │  TranscriptionPlugin        │\n│   sample_rate=16000 │                  │    .execute(                │\n│ )                   │                  │       audio=\"/tmp/xyz.wav\"  │\n│                     │                  │    )                        │\n│ plugin.execute(     │   HTTP/JSON      │                             │\n│   audio=audio       │ ─────────────────▶  # audio is now a PATH      │\n│ )                   │  (path string)   │  # Plugin reads from disk   │\n│                     │                  │                             │\n│ # Proxy detects     │                  │                             │\n│ # FileBackedDTO,    │                  │                             │\n│ # calls to_temp_file│                  │                             │\n└─────────────────────┘                  └─────────────────────────────┘\nThe RemotePluginProxy automatically: 1. Detects AudioData implements FileBackedDTO 2. Calls audio.to_temp_file() to save to disk 3. Sends the file path string to the Worker 4. Worker’s execute() receives a path, not the AudioData object",
    "crumbs": [
      "Transcription Plugin Interface"
    ]
  },
  {
    "objectID": "plugin_interface.html#example-implementation",
    "href": "plugin_interface.html#example-implementation",
    "title": "Transcription Plugin Interface",
    "section": "Example Implementation",
    "text": "Example Implementation\nA minimal transcription plugin that demonstrates the interface:\n\nfrom typing import Any, Dict, Optional\n\nclass ExampleTranscriptionPlugin(TranscriptionPlugin):\n    \"\"\"Example implementation showing how to create a transcription plugin.\"\"\"\n    \n    def __init__(self):\n        self._config: Dict[str, Any] = {}\n        self._model = None\n\n    @property\n    def name(self) -&gt; str:\n        return \"example-transcription\"\n    \n    @property\n    def version(self) -&gt; str:\n        return \"1.0.0\"\n    \n    @property\n    def supported_formats(self) -&gt; List[str]:\n        return [\"wav\", \"mp3\", \"flac\"]\n\n    def initialize(self, config: Optional[Dict[str, Any]] = None) -&gt; None:\n        \"\"\"Initialize with configuration.\"\"\"\n        self._config = config or {\"model\": \"base\"}\n        self._model = f\"MockModel-{self._config.get('model', 'base')}\"\n\n    def execute(\n        self,\n        audio: Union[AudioData, str, Path],\n        **kwargs\n    ) -&gt; TranscriptionResult:\n        \"\"\"Transcribe audio (receives file path when called via Proxy).\"\"\"\n        # In Worker process, audio is typically a string path\n        audio_path = str(audio) if not isinstance(audio, AudioData) else \"in-memory\"\n        \n        return TranscriptionResult(\n            text=f\"Transcribed from {audio_path}\",\n            confidence=0.95,\n            segments=[{\"start\": 0.0, \"end\": 1.0, \"text\": \"Mock transcription\"}],\n            metadata={\"model\": self._config.get(\"model\")}\n        )\n\n    def get_config_schema(self) -&gt; Dict[str, Any]:\n        \"\"\"Return JSON Schema for configuration.\"\"\"\n        return {\n            \"type\": \"object\",\n            \"properties\": {\n                \"model\": {\n                    \"type\": \"string\",\n                    \"enum\": [\"tiny\", \"base\", \"small\", \"medium\", \"large\"],\n                    \"default\": \"base\"\n                },\n                \"language\": {\n                    \"type\": \"string\",\n                    \"default\": \"en\"\n                }\n            }\n        }\n\n    def get_current_config(self) -&gt; Dict[str, Any]:\n        \"\"\"Return current configuration.\"\"\"\n        return self._config\n\n    def cleanup(self) -&gt; None:\n        \"\"\"Clean up resources.\"\"\"\n        self._model = None\n\n\n# Test the example plugin\nplugin = ExampleTranscriptionPlugin()\nplugin.initialize({\"model\": \"large\", \"language\": \"en\"})\n\nprint(f\"Plugin: {plugin.name} v{plugin.version}\")\nprint(f\"Supported formats: {plugin.supported_formats}\")\nprint(f\"Config schema: {plugin.get_config_schema()}\")\nprint(f\"Current config: {plugin.get_current_config()}\")\n\n# Test execution with a file path (as Worker would receive)\nresult = plugin.execute(\"/tmp/audio.wav\")\nprint(f\"\\nResult: {result}\")\n\n# Cleanup\nplugin.cleanup()\n\nPlugin: example-transcription v1.0.0\nSupported formats: ['wav', 'mp3', 'flac']\nConfig schema: {'type': 'object', 'properties': {'model': {'type': 'string', 'enum': ['tiny', 'base', 'small', 'medium', 'large'], 'default': 'base'}, 'language': {'type': 'string', 'default': 'en'}}}\nCurrent config: {'model': 'large', 'language': 'en'}\n\nResult: TranscriptionResult(text='Transcribed from /tmp/audio.wav', confidence=0.95, segments=[{'start': 0.0, 'end': 1.0, 'text': 'Mock transcription'}], metadata={'model': 'large'})",
    "crumbs": [
      "Transcription Plugin Interface"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "cjm-transcription-plugin-system",
    "section": "",
    "text": "pip install cjm_transcription_plugin_system",
    "crumbs": [
      "cjm-transcription-plugin-system"
    ]
  },
  {
    "objectID": "index.html#install",
    "href": "index.html#install",
    "title": "cjm-transcription-plugin-system",
    "section": "",
    "text": "pip install cjm_transcription_plugin_system",
    "crumbs": [
      "cjm-transcription-plugin-system"
    ]
  },
  {
    "objectID": "index.html#project-structure",
    "href": "index.html#project-structure",
    "title": "cjm-transcription-plugin-system",
    "section": "Project Structure",
    "text": "Project Structure\nnbs/\n├── core.ipynb             # DTOs for audio transcription with FileBackedDTO support for zero-copy transfer\n├── plugin_interface.ipynb # Domain-specific plugin interface for audio transcription\n└── storage.ipynb          # Standardized SQLite storage for transcription results with content hashing\nTotal: 3 notebooks",
    "crumbs": [
      "cjm-transcription-plugin-system"
    ]
  },
  {
    "objectID": "index.html#module-dependencies",
    "href": "index.html#module-dependencies",
    "title": "cjm-transcription-plugin-system",
    "section": "Module Dependencies",
    "text": "Module Dependencies\ngraph LR\n    core[core&lt;br/&gt;Core Data Structures]\n    plugin_interface[plugin_interface&lt;br/&gt;Transcription Plugin Interface]\n    storage[storage&lt;br/&gt;Transcription Storage]\n\n    plugin_interface --&gt; core\n1 cross-module dependencies detected",
    "crumbs": [
      "cjm-transcription-plugin-system"
    ]
  },
  {
    "objectID": "index.html#cli-reference",
    "href": "index.html#cli-reference",
    "title": "cjm-transcription-plugin-system",
    "section": "CLI Reference",
    "text": "CLI Reference\nNo CLI commands found in this project.",
    "crumbs": [
      "cjm-transcription-plugin-system"
    ]
  },
  {
    "objectID": "index.html#module-overview",
    "href": "index.html#module-overview",
    "title": "cjm-transcription-plugin-system",
    "section": "Module Overview",
    "text": "Module Overview\nDetailed documentation for each module in the project:\n\nCore Data Structures (core.ipynb)\n\nDTOs for audio transcription with FileBackedDTO support for zero-copy transfer\n\n\nImport\nfrom cjm_transcription_plugin_system.core import (\n    AudioData,\n    TranscriptionResult\n)\n\n\nClasses\n@dataclass\nclass AudioData:\n    \"\"\"\n    Container for raw audio data.\n    Implements FileBackedDTO for zero-copy transfer between Host and Worker processes.\n    \"\"\"\n    \n    samples: np.ndarray  # Audio sample data as numpy array\n    sample_rate: int  # Sample rate in Hz (e.g., 16000, 44100)\n    \n    def to_temp_file(self) -&gt; str: # Absolute path to temporary WAV file\n            \"\"\"Save audio to a temp file for zero-copy transfer to Worker process.\"\"\"\n            # Create temp file (delete=False so Worker can read it)\n            tmp = tempfile.NamedTemporaryFile(suffix=\".wav\", delete=False)\n            \n            # Ensure float32 format\n            audio = self.samples\n            if audio.dtype != np.float32\n        \"Save audio to a temp file for zero-copy transfer to Worker process.\"\n    \n    def to_dict(self) -&gt; Dict[str, Any]: # Serialized representation\n            \"\"\"Convert to dictionary for smaller payloads.\"\"\"\n            return {\n                \"samples\": self.samples.tolist(),\n        \"Convert to dictionary for smaller payloads.\"\n    \n    def from_file(\n            cls,\n            filepath: str # Path to audio file\n        ) -&gt; \"AudioData\": # AudioData instance\n        \"Load audio from a file.\"\n@dataclass\nclass TranscriptionResult:\n    \"Standardized output for all transcription plugins.\"\n    \n    text: str  # The transcribed text\n    confidence: Optional[float]  # Overall confidence (0.0 to 1.0)\n    segments: Optional[List[Dict[str, Any]]]  # Timestamped segments\n    metadata: Dict[str, Any] = field(...)  # Additional metadata\n\n\n\nTranscription Plugin Interface (plugin_interface.ipynb)\n\nDomain-specific plugin interface for audio transcription\n\n\nImport\nfrom cjm_transcription_plugin_system.plugin_interface import (\n    TranscriptionPlugin\n)\n\n\nClasses\nclass TranscriptionPlugin(PluginInterface):\n    \"\"\"\n    Abstract base class for all transcription plugins.\n    \n    Extends PluginInterface with transcription-specific requirements:\n    - `supported_formats`: List of audio file extensions this plugin can handle\n    - `execute`: Accepts audio path (str) or AudioData, returns TranscriptionResult\n    \n    NOTE: When running via RemotePluginProxy, AudioData objects are automatically\n    serialized to temp files via FileBackedDTO, so the Worker receives a file path.\n    \"\"\"\n    \n    def supported_formats(self) -&gt; List[str]: # e.g., ['wav', 'mp3', 'flac']\n            \"\"\"List of supported audio file extensions (without the dot).\"\"\"\n            ...\n    \n        @abstractmethod\n        def execute(\n            self,\n            audio: Union[AudioData, str, Path], # Audio data or file path\n            **kwargs\n        ) -&gt; TranscriptionResult: # Transcription result with text, confidence, segments\n        \"List of supported audio file extensions (without the dot).\"\n    \n    def execute(\n            self,\n            audio: Union[AudioData, str, Path], # Audio data or file path\n            **kwargs\n        ) -&gt; TranscriptionResult: # Transcription result with text, confidence, segments\n        \"Transcribe audio to text.\n\nWhen called via Proxy, AudioData is auto-converted to a file path string\nbefore reaching this method in the Worker process.\"\n\n\n\nTranscription Storage (storage.ipynb)\n\nStandardized SQLite storage for transcription results with content hashing\n\n\nImport\nfrom cjm_transcription_plugin_system.storage import (\n    TranscriptionRow,\n    TranscriptionStorage\n)\n\n\nClasses\n@dataclass\nclass TranscriptionRow:\n    \"A single row from the transcriptions table.\"\n    \n    job_id: str  # Unique job identifier\n    audio_path: str  # Path to the source audio file\n    audio_hash: str  # Hash of source audio in \"algo:hexdigest\" format\n    text: str  # Transcribed text output\n    text_hash: str  # Hash of transcribed text in \"algo:hexdigest\" format\n    segments: Optional[List[Dict[str, Any]]]  # Timestamped segments\n    metadata: Optional[Dict[str, Any]]  # Plugin metadata\n    created_at: Optional[float]  # Unix timestamp\nclass TranscriptionStorage:\n    def __init__(\n        self,\n        db_path: str  # Absolute path to the SQLite database file\n    )\n    \"Standardized SQLite storage for transcription results.\"\n    \n    def __init__(\n            self,\n            db_path: str  # Absolute path to the SQLite database file\n        )\n        \"Initialize storage and create table if needed.\"\n    \n    def save(\n            self,\n            job_id: str,        # Unique job identifier\n            audio_path: str,    # Path to the source audio file\n            audio_hash: str,    # Hash of source audio in \"algo:hexdigest\" format\n            text: str,          # Transcribed text output\n            text_hash: str,     # Hash of transcribed text in \"algo:hexdigest\" format\n            segments: Optional[List[Dict[str, Any]]] = None,  # Timestamped segments\n            metadata: Optional[Dict[str, Any]] = None         # Plugin metadata\n        ) -&gt; None\n        \"Save a transcription result to the database.\"\n    \n    def get_by_job_id(\n            self,\n            job_id: str  # Job identifier to look up\n        ) -&gt; Optional[TranscriptionRow]:  # Row or None if not found\n        \"Retrieve a transcription result by job ID.\"\n    \n    def list_jobs(\n            self,\n            limit: int = 100  # Maximum number of rows to return\n        ) -&gt; List[TranscriptionRow]:  # List of transcription rows\n        \"List transcription jobs ordered by creation time (newest first).\"\n    \n    def verify_audio(\n            self,\n            job_id: str  # Job identifier to verify\n        ) -&gt; Optional[bool]:  # True if audio matches, False if tampered, None if job not found\n        \"Verify the source audio file still matches its stored hash.\"\n    \n    def verify_text(\n            self,\n            job_id: str  # Job identifier to verify\n        ) -&gt; Optional[bool]:  # True if text matches, False if tampered, None if job not found\n        \"Verify the transcription text still matches its stored hash.\"",
    "crumbs": [
      "cjm-transcription-plugin-system"
    ]
  },
  {
    "objectID": "core.html",
    "href": "core.html",
    "title": "Core Data Structures",
    "section": "",
    "text": "source",
    "crumbs": [
      "Core Data Structures"
    ]
  },
  {
    "objectID": "core.html#testing-audiodata",
    "href": "core.html#testing-audiodata",
    "title": "Core Data Structures",
    "section": "Testing AudioData",
    "text": "Testing AudioData\nAudioData implements the FileBackedDTO protocol, which means the RemotePluginProxy will automatically serialize it to a temp file before sending to the Worker.\n\n# Test AudioData creation\naudio = AudioData(\n    samples=np.sin(np.linspace(0, 2*np.pi*440, 16000)),  # 1 second of 440Hz tone\n    sample_rate=16000\n)\n\nprint(f\"AudioData: {len(audio.samples)} samples at {audio.sample_rate}Hz\")\n\n# Test FileBackedDTO protocol\nprint(f\"\\nImplements FileBackedDTO: {isinstance(audio, FileBackedDTO)}\")\n\n# Test to_temp_file (this is what the Proxy calls)\ntemp_path = audio.to_temp_file()\nprint(f\"Saved to temp file: {temp_path}\")\n\n# Verify the file exists and can be read back\nimport os\nprint(f\"File exists: {os.path.exists(temp_path)}\")\nprint(f\"File size: {os.path.getsize(temp_path)} bytes\")\n\n# Clean up\nos.unlink(temp_path)\n\nAudioData: 16000 samples at 16000Hz\n\nImplements FileBackedDTO: True\nSaved to temp file: /tmp/tmpy7vrwehx.wav\nFile exists: True\nFile size: 32044 bytes\n\n\n\n# Test TranscriptionResult\nresult = TranscriptionResult(\n    text=\"Hello world\",\n    confidence=0.95,\n    segments=[\n        {\"start\": 0.0, \"end\": 0.5, \"text\": \"Hello\"},\n        {\"start\": 0.5, \"end\": 1.0, \"text\": \"world\"}\n    ],\n    metadata={\"model\": \"whisper-large-v3\", \"language\": \"en\"}\n)\n\nprint(f\"Text: {result.text}\")\nprint(f\"Confidence: {result.confidence}\")\nprint(f\"Segments: {result.segments}\")\nprint(f\"Metadata: {result.metadata}\")\n\nText: Hello world\nConfidence: 0.95\nSegments: [{'start': 0.0, 'end': 0.5, 'text': 'Hello'}, {'start': 0.5, 'end': 1.0, 'text': 'world'}]\nMetadata: {'model': 'whisper-large-v3', 'language': 'en'}\n\n\n\n# Test minimal result (only text required)\nminimal = TranscriptionResult(text=\"Just the text\")\nprint(f\"Minimal result: {minimal}\")\n\n# Test from_file class method (if audio file available)\n# audio_loaded = AudioData.from_file(\"path/to/audio.wav\")\n\nMinimal result: TranscriptionResult(text='Just the text', confidence=None, segments=None, metadata={})",
    "crumbs": [
      "Core Data Structures"
    ]
  },
  {
    "objectID": "storage.html",
    "href": "storage.html",
    "title": "Transcription Storage",
    "section": "",
    "text": "A dataclass representing a single row in the standardized transcriptions table. This provides a type-safe way to work with stored transcription results.\n\nsource\n\n\n\ndef TranscriptionRow(\n    job_id:str, audio_path:str, audio_hash:str, text:str, text_hash:str, segments:Optional=None,\n    metadata:Optional=None, created_at:Optional=None\n)-&gt;None:\n\nA single row from the transcriptions table.\n\n# Test TranscriptionRow creation\nrow = TranscriptionRow(\n    job_id=\"job_abc123\",\n    audio_path=\"/tmp/test.mp3\",\n    audio_hash=\"sha256:\" + \"a\" * 64,\n    text=\"Hello world\",\n    text_hash=\"sha256:\" + \"b\" * 64,\n    segments=[{\"start\": 0.0, \"end\": 1.0, \"text\": \"Hello world\"}],\n    metadata={\"model\": \"whisper-large-v3\"}\n)\n\nprint(f\"Row: job_id={row.job_id}, text={row.text[:20]}...\")\nprint(f\"Audio hash: {row.audio_hash[:20]}...\")\nprint(f\"Text hash: {row.text_hash[:20]}...\")\n\nRow: job_id=job_abc123, text=Hello world...\nAudio hash: sha256:aaaaaaaaaaaaa...\nText hash: sha256:bbbbbbbbbbbbb...",
    "crumbs": [
      "Transcription Storage"
    ]
  },
  {
    "objectID": "storage.html#transcriptionrow",
    "href": "storage.html#transcriptionrow",
    "title": "Transcription Storage",
    "section": "",
    "text": "A dataclass representing a single row in the standardized transcriptions table. This provides a type-safe way to work with stored transcription results.\n\nsource\n\n\n\ndef TranscriptionRow(\n    job_id:str, audio_path:str, audio_hash:str, text:str, text_hash:str, segments:Optional=None,\n    metadata:Optional=None, created_at:Optional=None\n)-&gt;None:\n\nA single row from the transcriptions table.\n\n# Test TranscriptionRow creation\nrow = TranscriptionRow(\n    job_id=\"job_abc123\",\n    audio_path=\"/tmp/test.mp3\",\n    audio_hash=\"sha256:\" + \"a\" * 64,\n    text=\"Hello world\",\n    text_hash=\"sha256:\" + \"b\" * 64,\n    segments=[{\"start\": 0.0, \"end\": 1.0, \"text\": \"Hello world\"}],\n    metadata={\"model\": \"whisper-large-v3\"}\n)\n\nprint(f\"Row: job_id={row.job_id}, text={row.text[:20]}...\")\nprint(f\"Audio hash: {row.audio_hash[:20]}...\")\nprint(f\"Text hash: {row.text_hash[:20]}...\")\n\nRow: job_id=job_abc123, text=Hello world...\nAudio hash: sha256:aaaaaaaaaaaaa...\nText hash: sha256:bbbbbbbbbbbbb...",
    "crumbs": [
      "Transcription Storage"
    ]
  },
  {
    "objectID": "storage.html#transcriptionstorage",
    "href": "storage.html#transcriptionstorage",
    "title": "Transcription Storage",
    "section": "TranscriptionStorage",
    "text": "TranscriptionStorage\nStandardized SQLite storage that all transcription plugins should use. Defines the canonical schema for the transcriptions table with content hash columns for traceability.\nSchema:\nCREATE TABLE IF NOT EXISTS transcriptions (\n    id INTEGER PRIMARY KEY AUTOINCREMENT,\n    job_id TEXT UNIQUE NOT NULL,\n    audio_path TEXT NOT NULL,\n    audio_hash TEXT NOT NULL,\n    text TEXT NOT NULL,\n    text_hash TEXT NOT NULL,\n    segments JSON,\n    metadata JSON,\n    created_at REAL NOT NULL\n);\nThe audio_hash and text_hash columns use the self-describing \"algo:hexdigest\" format (e.g., \"sha256:a3f2b8...\"), enabling downstream consumers to verify content integrity.\n\nsource\n\nTranscriptionStorage\n\ndef TranscriptionStorage(\n    db_path:str, # Absolute path to the SQLite database file\n):\n\nStandardized SQLite storage for transcription results.",
    "crumbs": [
      "Transcription Storage"
    ]
  },
  {
    "objectID": "storage.html#testing",
    "href": "storage.html#testing",
    "title": "Transcription Storage",
    "section": "Testing",
    "text": "Testing\n\nimport tempfile\nimport os\n\n# Create storage with temp database\ntmp_db = tempfile.NamedTemporaryFile(suffix=\".db\", delete=False)\nstorage = TranscriptionStorage(tmp_db.name)\n\nprint(f\"Storage initialized at: {tmp_db.name}\")\n\nStorage initialized at: /tmp/tmppclxq8cq.db\n\n\n\n# Save a transcription result with hashes\ntest_text = \"Laying Plans Sun Tzu said, The art of war is of vital importance to the state.\"\ntext_hash = hash_bytes(test_text.encode())\naudio_hash = \"sha256:\" + \"e3b0c44298\" * 6 + \"e3b0\"  # Simulated audio hash\n\nstorage.save(\n    job_id=\"job_test_001\",\n    audio_path=\"/tmp/test_audio.mp3\",\n    audio_hash=audio_hash,\n    text=test_text,\n    text_hash=text_hash,\n    segments=[{\"start\": 0.0, \"end\": 5.0, \"text\": test_text}],\n    metadata={\"model\": \"whisper-large-v3\", \"language\": \"en\"}\n)\n\nprint(f\"Saved job_test_001\")\nprint(f\"Text hash: {text_hash}\")\n\nSaved job_test_001\nText hash: sha256:83efd1674de9fcf20e5c2edacf9246f7f34ad04bf07ddcb2b4e2765269e1edd1\n\n\n\n# Retrieve by job ID\nrow = storage.get_by_job_id(\"job_test_001\")\nassert row is not None\nassert row.job_id == \"job_test_001\"\nassert row.text == test_text\nassert row.text_hash == text_hash\nassert row.audio_hash == audio_hash\nassert row.segments is not None\nassert row.metadata[\"model\"] == \"whisper-large-v3\"\nassert row.created_at is not None\n\nprint(f\"Retrieved: {row.job_id}\")\nprint(f\"Text: {row.text[:40]}...\")\nprint(f\"Audio hash: {row.audio_hash[:30]}...\")\nprint(f\"Text hash: {row.text_hash[:30]}...\")\nprint(f\"Created at: {row.created_at}\")\n\nRetrieved: job_test_001\nText: Laying Plans Sun Tzu said, The art of wa...\nAudio hash: sha256:e3b0c44298e3b0c44298e3b...\nText hash: sha256:83efd1674de9fcf20e5c2ed...\nCreated at: 1770425259.7641876\n\n\n\n# Missing job returns None\nmissing = storage.get_by_job_id(\"nonexistent\")\nassert missing is None\nprint(\"get_by_job_id returns None for missing job: OK\")\n\nget_by_job_id returns None for missing job: OK\n\n\n\n# Save another and test list_jobs\nstorage.save(\n    job_id=\"job_test_002\",\n    audio_path=\"/tmp/test_audio_2.mp3\",\n    audio_hash=\"sha256:\" + \"f\" * 64,\n    text=\"Second transcription.\",\n    text_hash=hash_bytes(b\"Second transcription.\")\n)\n\njobs = storage.list_jobs()\nassert len(jobs) == 2\n# Newest first\nassert jobs[0].job_id == \"job_test_002\"\nassert jobs[1].job_id == \"job_test_001\"\n\nprint(f\"list_jobs returned {len(jobs)} rows (newest first): {[j.job_id for j in jobs]}\")\n\nlist_jobs returned 2 rows (newest first): ['job_test_002', 'job_test_001']\n\n\n\n# Test text verification\nassert storage.verify_text(\"job_test_001\") == True\nprint(\"verify_text with unchanged text: True\")\n\n# Tamper with text directly in DB\nwith sqlite3.connect(tmp_db.name) as con:\n    con.execute(\"UPDATE transcriptions SET text = 'TAMPERED' WHERE job_id = 'job_test_001'\")\n\nassert storage.verify_text(\"job_test_001\") == False\nprint(\"verify_text after tampering: False\")\n\n# Missing job returns None\nassert storage.verify_text(\"nonexistent\") is None\nprint(\"verify_text for missing job: None\")\n\nverify_text with unchanged text: True\nverify_text after tampering: False\nverify_text for missing job: None\n\n\n\n# Cleanup\nos.unlink(tmp_db.name)\nprint(\"Cleanup complete\")\n\nCleanup complete",
    "crumbs": [
      "Transcription Storage"
    ]
  }
]